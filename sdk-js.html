<!DOCTYPE html><html><head><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>sdk-js</title></head><body><hr />
<p>layout: default
title: JavaScript SDK
description: Build HTML5 games for the Phune Gaming platform</p>
<hr />
<hr />

<div data-magellan-destination="sdk-js" data-magellan-expedition="fixed" data-options="destination_threshold: 65;">
    <dl class="sub-nav">
        <dt>Jump to:</dt>
        <dd data-magellan-arrival="install"><a href="#install">Install</a></dd>
        <dd data-magellan-arrival="getting-started"><a href="#getting-started">Getting Started</a></dd>
        <dd data-magellan-arrival="public-api"><a href="#public-api">Public API</a></dd>
    </dl>
</div>

<hr />

<p><a name="install"></a>
<h3 data-magellan-destination="install">Install</h3></p>
<p>Install the JavaScript SDK with <a href="http://bower.io/">Bower</a> from the command-line:</p>
<pre><code>bower install phune-gaming-sdk
</code></pre>

<p>Add Phune Gaming SDK to your <code>index.html</code>:</p>
<pre><code class="html">&lt;script src=&quot;/bower_components/phune-gaming-sdk/dist/PG.min.js&quot;&gt;&lt;/script&gt;
</code></pre>

<p>Alternatively, for those who do not use Bower, you can directly <a href="https://github.com/phune-gaming/pg-sdk-js/releases">download the Phune Gaming SDK from GitHub</a>.</p>
<p>You are now ready to start your game implementation. Please proceed to the <a href="#getting-started">Getting Started</a> sub-section to find which callbacks your game needs to implement to process the messages sent by the platform, and to the <a href="#public-api">Public API</a> sub-section to find out which methods you have available to send the game messages (e.g. moves) to the server.</p>
<p>The <a href="https://github.com/phune-gaming/pg-tic-tac-toe">implementation of the game Tic-Tac-Toe</a> is freely available on GitHub.</p>
<hr />

<p><a name="getting-started"></a>
<h3 data-magellan-destination="getting-started">Getting Started</h3></p>
<p>Initialize the JavaScript SDK by calling <code>PG.init</code> and defining the callback functions which will handle all matchmaking states and the game events sent to your game by the platform:</p>
<pre><code class="js">PG.init({
    onMatchPrepare: function(player, opponent, deviceType) {
        // ...
    },
    onGameLobby: function(allowedTime) {
        // ...
    },
    onMatchStart: function(playerIdToPlayNext, timeToPlay) {
        // ...
    },
    onMoveValid: function(playerIdWhoSentTheMove, playerIdToPlayNext, moveDetails, moveResults, gameResults) {
        // ...
    },
    onMoveInvalid: function(playerIdWhoSentTheMove, playerIdToPlayNext) {
        // ...
    },
    onServerMessage: function(playerIdWhoSentTheMessage, messageDetails, messageResults) {
        // ...
    },
    onPlayerMessage: function(messageDetails) {
        // ...
    },
    onMatchEnd: function(gameResults) {
        // ...
    },
    onKeyPress: function(key) { // TV only
        // ...
    }
});
</code></pre>

<p>Please find below a detailed description for each callback.</p>
<h4 id="match-prepare">Match prepare</h4>
<p>During the match preparation phase, the game should build the user interface and get ready to start playing. It is provided with the details of the player and opponent, and in which type of device the game is running ('mobile' or 'tv').</p>
<pre><code class="js">onMatchPrepare: function(player, opponent, deviceType) {
    // ...
},
</code></pre>

<h4 id="game-lobby">Game lobby</h4>
<p>If the game needs to configure the match details before it is started, the <code>onGameLobby</code> callback function will be called to allow it to do so. It is provided with the time allowed for the player to configure the game and start the match.</p>
<pre><code class="js">onGameLobby: function(allowedTime) {
    // ...
},
</code></pre>

<h4 id="match-start">Match start</h4>
<p>When the match starts the game will be informed of which player should start playing and the time allowed for each player to make a move.</p>
<pre><code class="js">onMatchStart: function(playerIdToPlayNext, timeToPlay) {
    // ...
},
</code></pre>

<h4 id="moves-handling-and-validation">Moves handling and validation</h4>
<p>If a move is considered valid by the server-side rules, the server will respond with a confirmation message that will be handled by the <code>onMoveValid</code> callback function. Moves performed by the opponent will also be handled by this callback function.</p>
<p>If a move ends the game, the <code>gameResults</code> parameter will indicate how the game ended. Possible values are 'won', 'lost', and 'draw'.</p>
<pre><code class="js">onMoveValid: function(playerIdWhoSentTheMove, playerIdToPlayNext, moveDetails, moveResults, gameResults) {
    // ...
},
</code></pre>

<p>If a move does not pass the server-side rules validation, the game will be notified by the <code>onMoveInvalid</code> callback function.</p>
<pre><code class="js">onMoveInvalid: function(playerIdWhoSentTheMove, playerIdToPlayNext) {
    // ...
},
</code></pre>

<h4 id="handle-messages-from-the-server">Handle messages from the server</h4>
<p>Responses to messages sent to the server will be processed by the <code>onServerMatch</code> callback function.</p>
<pre><code class="js">onServerMessage: function(playerIdWhoSentTheMessage, messageDetails, messageResults) {
    // ...
},
</code></pre>

<h4 id="handle-messages-from-an-opponent">Handle messages from an opponent</h4>
<p>Messages sent by the opponent will be processed by the <code>onPlayerMessage</code> callback function.</p>
<pre><code class="js">onPlayerMessage: function(messageDetails) {
    // ...
},
</code></pre>

<h4 id="match-end">Match end</h4>
<p>When the game ends, the <code>onMatchEnd</code> callback function is called with the end condition. Possible values are 'won', 'lost', and 'draw'.</p>
<pre><code class="js">onMatchEnd: function(gameResults) {
    switch (gameResults) {
    case 'won':
        // ...
        break;
    case 'lost':
        // ...
        break;
    default:
        // draw...
        break;
    }
},
</code></pre>

<h4 id="tv-remote-control-input-handling">TV remote control input handling</h4>
<p>On TV environment, the <code>onKeyPress</code> callback handles the remote control keys that were pressed. The possible values are: 'left', 'right', 'up', 'down' and 'enter'.</p>
<pre><code class="js">onKeyPress: function(key) {
    switch(key) {
    case 'left':
        // ...
        break;
    case 'right':
        // ...
        break;
    case 'up':
        // ...
        break;
    case 'down':
        // ...
        break;
    case 'enter':
        // ...
        break;
    }
}
</code></pre>

<hr />

<p><a name="public-api"></a>
<h3 data-magellan-destination="public-api">Public API</h3></p>
<p>The Phune Gaming SDK provides an <a href="http://phune-gaming.github.io/pg-sdk-js/">API</a> with the public methods as detailed below.</p>
<h4 id="match-start_1">Match start</h4>
<p>During the match preparation phase (<code>onMatchPrepare</code> callback) the game must inform the platform when it is ready to be shown to the user by calling <code>PG.ready</code>.</p>
<pre><code class="js">PG.ready();
</code></pre>

<h4 id="game-lobby_1">Game lobby</h4>
<p>If the game is configured on the server to require a configuration phase, the (<code>onGameLobby</code> callback) will be called to allow the game to send the required configuration back to the server by calling <code>PG.serverMessage</code>. When finished, it must inform the platform that the match is ready to start by calling <code>PG.exitGameLobby</code>.</p>
<pre><code class="js">PG.exitGameLobby();
</code></pre>

<h4 id="send-messages-to-the-server">Send messages to the server</h4>
<p>It is possible to send messages to be evaluated by the server-side rules. You can specify if you want the response to be sent to both players or only to yourself. Additionally you can also indicate if you want the messages to be processed by the server-side rules in order of arrival or in parallel.</p>
<pre><code class="js">PG.serverMessage(
    messageObject,    // any message content can be passed here
    false,            // should the response be sent to both players?
    true              // should the message be processed by the order of arrival?
);
</code></pre>

<h4 id="send-messages-to-the-opponent">Send messages to the opponent</h4>
<p>If the game requires to send messages to the opponent that should not be evaluated by the server-side rules, it can use this function. Optionally, you can specify if you do not want to allow more than one message to be sent within the specified time in milliseconds. If this is called more than once during this interval only the last message will be sent.</p>
<pre><code class="js">PG.playerMessage(
    messageObject,    // any message content can be passed here
    150               // do not send more than one message during this interval
);
</code></pre>

<h4 id="perform-a-move">Perform a move</h4>
<p>If it is the current player turn, the game should allow the player to make a move and then send it to the platform. Optionally, you can specify a validate function that accepts the move object as a parameter and validates it before sending it to the server. This prevents additional round-trips to the server for invalid moves, thus making the game a lot more responsive.</p>
<pre><code class="js">PG.move(
    moveObject,         // any move details can be passed here
    validateFunction    // function to validate the move
);
</code></pre>

<h4 id="show-the-platform-menu">Show the platform menu</h4>
<p>The game must include a visual component allowing a user to call for the platform menu. In order to show the menu that component must call the function <code>PG.showMenu</code>.</p>
<pre><code class="js">PG.showMenu();
</code></pre>

<hr />

<p>What's next? Go to <a href="/server-rules.html">Server rules</a> to find how to do your game validations on the server.</p></body></html>